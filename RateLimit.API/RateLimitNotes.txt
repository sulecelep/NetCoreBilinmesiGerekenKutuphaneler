


appsettingjson:

"IpRateLimitPolicies": {
    "IpRules": [
      {
        "Ip": "::1",
        "Rules": [
          {
            "Endpoint": "*",
            "Period": "30s",
            "Limit": 30
          }
        ]
      }
    ]
  },

  "IpRateLimiting": {
    "EnableEndpointRateLimiting": true,
    "StackBlockedRequests": false,
    "HttpStatusCode": 429,
    "IpWhitelist": [ "127.0.0.1" ],
    "GeneralRules": [
      {
        "Endpoint": "*:/api/product",
        "Period": "20s",
        "Limit": 3
      },
      {
        "Endpoint": "*:/api/product",
        "Period": "1h",
        "Limit": 100
      },
      {
        "Endpoint": "*:/api/categories",
        "Period": "30s",
        "Limit": 5
      },
      {
        "Endpoint": "*:/api/categories",
        "Period": "1d",
        "Limit": 500
      }
    ]

  },

  startup:
            services.AddOptions(); //addsettingjson'a erişebilecek
            services.AddMemoryCache();  //Hangi endpointe kaç istek yapılmış memory'de tutacak
            services.Configure<IpRateLimitOptions>(Configuration.GetSection("IpRateLimiting"));
            services.Configure<IpRateLimitPolicies>(Configuration.GetSection("IpRateLimitPolicies"));
            services.AddSingleton<IIpPolicyStore, MemoryCacheIpPolicyStore>();
            services.AddSingleton<IRateLimitCounterStore, MemoryCacheRateLimitCounterStore>();
            services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();
            services.AddSingleton<IRateLimitConfiguration,RateLimitConfiguration>();    
    
            app.UseIpRateLimiting();

program.cs:
 public static void Main(string[] args)
        {
            var webhost=  CreateHostBuilder(args).Build();
            var IpPolicy = webhost.Services.GetRequiredService<IIpPolicyStore>();
            IpPolicy.SeedAsync().Wait();
            webhost.Run();
        }



        //Burada eğer Limiting kısmındaki kuraldan daha kapsamlayıcıysa 
IpRateLimitPolicies kısmıındaki kurallar geçerli olur. Yani IpRateLimitPolicies
IpRateLimiting'i ezer.


Eğer rot balancer kullanıyorsak ve Header'dan değişken olarak Ip adresini almak istiyorsak IpRateLimiting'e parametre olarak key eklicez.

"IpRateLimiting": {
    "EnableEndpointRateLimiting": true,
    "RealIpHeader": "X-Real-IP",
    "StackBlockedRequests": false,
    "HttpStatusCode": 429,
    "IpWhitelist": [ "127.0.0.1" ],
    "GeneralRules": [
      {
        "Endpoint": "*:/api/product",
        "Period": "20s",
        "Limit": 3
      },
      {
        "Endpoint": "*:/api/product",
        "Period": "1h",
        "Limit": 100
      },
      {
        "Endpoint": "*:/api/categories",
        "Period": "30s",
        "Limit": 5
      },
      {
        "Endpoint": "*:/api/categories",
        "Period": "1d",
        "Limit": 500
      }
    ]

  },



  //EndpointWhitelist

  Bu kurallardan muaf tutulacak endpointleri burada belirtiyoruz
  "IpRateLimiting": {
    "EnableEndpointRateLimiting": true,
    "RealIpHeader": "X-Real-IP",
    "StackBlockedRequests": false,
    "HttpStatusCode": 429,
    "IpWhitelist": [ "127.0.0.1" ],
    "EndpointWhitelist": [ "put:/api/product" ],
    "GeneralRules": [
      {
        "Endpoint": "*:/api/product",
        "Period": "20s",
        "Limit": 3
      },
      {
        "Endpoint": "*:/api/product",
        "Period": "1h",
        "Limit": 100
      },
      {
        "Endpoint": "*:/api/categories",
        "Period": "30s",
        "Limit": 5
      },
      {
        "Endpoint": "*:/api/categories",
        "Period": "1d",
        "Limit": 500
      }
    ]

  },


  // QuotaExceededResponse
  İstek sınırını aşarsa geriye ingilizce mesaj dönüyordu onu değiştireceğiz.

   "IpRateLimiting": {
    "QuotaExceededResponse": {
      "Content": "{{\"mesaj\":\"İstek limiti aşıldı.\" , \"Detay: \": \" İzin verilen istek sayısı {1}'de {0} istektir. {2} sonra tekrar deneyebilirsiniz. \" }}",
      "ContentType": "application/json"
    },
    "EnableEndpointRateLimiting": true,
    "StackBlockedRequests": false,
    "HttpStatusCode": 429,
    "IpWhitelist": [ "127.0.0.1" ],
    "EndpointWhitelist": [ "put:/api/product" ],
    "GeneralRules": [
      {
        "Endpoint": "*:/api/product",
        "Period": "20s",
        "Limit": 3
      },
      {
        "Endpoint": "*:/api/product",
        "Period": "1h",
        "Limit": 100
      },
      {
        "Endpoint": "*:/api/categories",
        "Period": "30s",
        "Limit": 5
      },
      {
        "Endpoint": "*:/api/categories",
        "Period": "1d",
        "Limit": 500
      }
    ]

  },


  //Endpoint'lerin url'de parametre alma durumu

  {
        "Endpoint": "*:/api/product/*", //eğer parametre alıyorsa sonuna yıldız ekliyoruz *:/api/product/*
        "Period": "30s",
        "Limit": 5
      },



//Client Rate Limit


program:

            var webhost=  CreateHostBuilder(args).Build();
            //var IpPolicy = webhost.Services.GetRequiredService<IIpPolicyStore>();
            //IpPolicy.SeedAsync().Wait();
            webhost.Run();


startup:

            services.AddOptions(); //addsettingjson'a erişebilecek
            services.AddMemoryCache();  //Hangi endpointe kaç istek yapılmış memory'de tutacak
            //services.Configure<IpRateLimitOptions>(Configuration.GetSection("IpRateLimiting"));
            services.Configure<ClientRateLimitOptions>(Configuration.GetSection("ClientRateLimiting"));
            //services.Configure<IpRateLimitPolicies>(Configuration.GetSection("IpRateLimitPolicies"));
            services.Configure<ClientRateLimitPolicies>(Configuration.GetSection("ClientRateLimitPolicies"));
            //services.AddSingleton<IIpPolicyStore, MemoryCacheIpPolicyStore>();
            services.AddSingleton<IClientPolicyStore, MemoryCacheClientPolicyStore>();
            services.AddSingleton<IRateLimitCounterStore, MemoryCacheRateLimitCounterStore>();
            services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();
            services.AddSingleton<IRateLimitConfiguration,RateLimitConfiguration>();    
            
            app.UseClientRateLimiting();

appsettingjson:

"IpRateLimiting": {
    "QuotaExceededResponse": {
      "Content": "{{\"mesaj\":\"İstek limiti aşıldı.\" , \"Detay: \": \" İzin verilen istek sayısı {1}'de {0} istektir. {2} sonra tekrar deneyebilirsiniz. \" }}",
      "ContentType": "application/json"
    },
    "EnableEndpointRateLimiting": true,
    "StackBlockedRequests": false,
    "HttpStatusCode": 429,
    //"IpWhitelist": [ "127.0.0.1" ],
    "ClientIdHeader": "X-ClientId",
    "ClientWhitelist": [ "client-1" ],
    "EndpointWhitelist": [ "put:/api/product" ],
    "GeneralRules": [
      {
        "Endpoint": "*:/api/product",
        "Period": "20s",
        "Limit": 3
      },
      {
        "Endpoint": "*:/api/product",
        "Period": "1h",
        "Limit": 100
      },
      {
        "Endpoint": "*:/api/product/*", //eğer parametre alıyorsa sonuna yıldız ekliyoruz *:/api/product/*
        "Period": "30s",
        "Limit": 5
      },
      {
        "Endpoint": "*:/api/categories",
        "Period": "30s",
        "Limit": 5
      },
      {
        "Endpoint": "*:/api/categories",
        "Period": "1d",
        "Limit": 500
      }
    ]

  },

  postman'de denerken Headers kısmında Key yerine  X-ClientId
                                       Value yerine client-1   yazarak denemeliyiz.
                                       Böylelikle kural ve kısıtlamalardan muaf olurlar.

Kötü niyetli kullanıcılar key ve value'yu öğrenip suistimal edebilirler. 
Ip ile yapmak daha güvenlidir.